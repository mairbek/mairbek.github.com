---
name: Microbenchmarking with Caliper
layout: default
title: Microbenchmarking with Caliper 
time: 2012-01-09 12:49:00 +02:00
---


<p>
Бывает, что перед нами, разработчиками, возникает проблема выбора той или иной реализации алгоритма или структуры данных подходящей для решения текущей задачи.
</p>

<p>
Чаще всего, конечно, можно воспользоваться <a href="http://google.com">гуглом</a>, задать вопрос на <a href="http://stackoverflow.com/">stackoverflow</a>, но в некоторых ситуациях ничего не остается, кроме как провести эксперименты самому.
</p>

<p>
Такая инженерная практика именуется <i>microbenchmarking</i>. Суть микробенчмаркинга в измерении производительности (загрузки процессора, памяти или операций с сетью, диском) небольших кусков кода для того, чтобы понять какой код лучше подходит для текущего сценария.
</p>

<p>
Стоит заметить, что микробенчмаркинг и профайлинг -- это не одно и то же. Различия между ними напоминают различия между unit тестированием и интеграционным тестированием. Профайлинг подразумевает исследование производительности всего приложения в целом, тогда как микробенчмаркинг -- это, в свою очередь, исследование актуальной в данный момент функциональности. 
</p>

<p>
Зная что нужно измерять, написать бенчмарк довольно тривиально, и, часто, вполне можно обойтись одним единственным статическим методом main. Однако, используя фреймверк <a href="http://code.google.com/p/caliper/">Caliper</a> от компании Google, бенчмарки можно писать быстро и с удовольствием, выкинув при этом кучу boilerplate кода.
</p>

<p>
API Caliper в чем то напоминает старую версию JUnit. Для того чтобы написать простой бенчмарк нужно:
</p>

<ol>
  <li>Отнаследоваться от класса <i>com.google.caliper.SimpleBenchmark</i></li>
  <li>Написать тестовые методы, название которых начинается со слова <i>time</i>.</li>
  <li>Подготовка данных и очистка ресурсов происходит в методах <i>setUp</i> и <i>tearDown</i> соответственно.</li>
</ol>

<p>
Caliper изначально поставляется с большим количеством примеров. Один из интересных <i>LoopingBackwardsBenchmark</i>, который сравнивает скорость итерирования вперед и назад.
</p>

{% highlight java %}
public class LoopingBackwardsBenchmark extends SimpleBenchmark {
    @Param({"2", "20", "2000", "2000000", "20000000", "200000000"})
    private int max;


    public int timeForwards(int reps) {
        int dummy = 0;
        for (int i = 0; i < reps; i++) {
            for (int j = 0; j < max; j++) {
                dummy += j;
            }
        }
        return dummy;
    }


    public int timeBackwards(int reps) {
        int dummy = 0;
        for (int i = 0; i < reps; i++) {
            for (int j = max - 1; j >= 0; j--) {
                dummy += j;
            }
        }
        return dummy;
    }


    public static void main(String[] args) throws Exception {
        Runner.main(LoopingBackwardsBenchmark.class, args);
    }


}


{% endhighlight %}

<p>
Запустив тест мы убедимся, что разницы в производительности нет.
</p>

<p>
Еще один пример. Допустим, мы разрабатываем функциональность которая предполагает огромное количество операций над дробными числами, и мы думаем стоит ли использовать <i>BigDecimal</i> или лучше остановить свой выбор на старом добром быстром <i>double</i>. Сравнить насколько медленней будет работать BigDecimal для такой операции как умножение не сложно.
</p>


{% highlight java %}
public class DoubleVsBigDecimalBenchmark extends SimpleBenchmark {
    @Param({"1", "1.01", "1.0123456789", "20", "20.01", "20.0123456789", "1000000000", "1000000000.01", "1000000000.0123456789"})
    private double value;

    private BigDecimal[] bigDecimalVal = new BigDecimal[1];
    private double[] doubleVal = new double[1];

    @Override
    protected void setUp() throws Exception {
        bigDecimalVal[0] = BigDecimal.valueOf(value);
        doubleVal[0] = value;
    }


    public void timeDouble(int reps) {
        double dummy = 0;
        for (int i = 0; i < reps; i++) {
            int v = i / (reps + 1);
            dummy = doubleVal[v] * doubleVal[v];
        }
        doubleVal[0] = dummy;
    }

    public void timeBigDecimal(int reps) {
        BigDecimal dummy = BigDecimal.ZERO;
        for (int i = 0; i < reps; i++) {
            int v = i / (reps + 1);
            dummy = bigDecimalVal[v].multiply(bigDecimalVal[v]);
        }
        bigDecimalVal[0] = dummy;
    }

    public static void main(String[] args) {
        Runner.main(DoubleVsBigDecimalBenchmark.class, new String[]{});
    }

}
{% endhighlight %}

<p>
Прогнав тест, становится видно, что для небольших чисел и чисел с небольшой дробной частью <i>BigDecimal</i> работает в 5 раз медленней, а для больших чисел либо чисел с большим количеством символов после запятой в 20 раз.
</p>

<p>
Следует заметить, что <i>JVM</i> хитрая штука, и постоянно занимается оптимизацией кода, что сказывается на результатах бенчмарка, по-этому иногда надо выкручиваться. Например, в бенчмарке <i>DoubleVsBigDecimalBenchmark</i> используется массив и странный способ инициализации переменной v нулем.
</p>
