---
name: Coordination in Distributed Systems
layout: post
title: Coordination in Distributed Systems
location: Kharkiv, Ukraine
time: 2013-02-07 09:49:00 +02:00
---

<p>
	Facing a coordination problem is almost one hundred percent guaranteed if you are working on a distributed system. Despite that we might strive for <a href="http://en.wikipedia.org/wiki/Shared_nothing_architecture">shared nothing architecture</a> where every node is able to work independently from others, there are some tasks that simply require at least decent amount of coordinating activity.
</p>

<p>
	What do I mean by coordination? Well, let's start with the simple problem. Common challenge in distributed systems is getting the <b>naming</b> right. Many distributed algorithms should be able to distinguish one process from another in order to work correctly. The trick is to come up with the solution that works in a distributed way, gives a processes unambiguously identifiable names among the system, and could support dynamic addition and removal of the nodes in cluster.
</p>

<p>
	<b>Configuration management</b> is an another coordination problem that pops out frequently. Every sophisticated system has to deal with the configuration information. Property files may sound great but let's imaging you have hundreds of nodes in the cluster running particular deployment packages and now you have to change the configuration property on all of this servers. It turns out that property files are great if configuration is static but using them for dynamic configuration doesn't seems to be good idea.
</p>

<p>
	To explain next problem named <b>group membership</b> let's picture some real world project. Imagine you are working on a social network web-site and there are two types of distributed processes: front-end servers that handles http requests and image servers responsible for efficient image storage. Whenever user uploads the photo, front-end server has to communicate with the image storage to save the image, so front-end server has to be configured to know the addresses of the image servers. Now imagine that photo sharing feature becomes extremely popular and we need to increase number of image servers in order to handle all content uploads. In addition let's be realistic and accept the fact that some of the servers might fail and we need to track that information and avoid sending requests to the failed server. Sounds non-trivial.
</p>

<p>
	If you worked on multi-threaded programs, apparently you should be familiar with the concurrency issues. Developing distributed app we basically face the same challenges as we would face in the multi-threaded environment plus. In the distributed system race conditions between the processes could easily happen if there are some shared resources, so you might look forward to implement some decent <b>locking</b> mechanism to solve them. Race condition is not the only issue, some of your data may require ACID guaranties (atomicity, consistency, integrity and durability) and you should be ready to implement custom <b>transactions</b>.
</p>

<p>
	Many popular distributed databases, search servers, file systems require single master node to coordinate activities across other nodes in some way. But how do you select the master? Obvious way to do this is to choose it by yourself. It will work but as we know already, predefined configuration is not that flexible. Plus, remember we are living in distributed world, we need master to be fault tolerant: in case if current master crashes some other node should come up and do the job. The problem of automatically select(elect) master(leader) process is called <b>leader election</b>. Technically speaking leader election is the same old <b>locking</b> problem. Think of leader as a process that acquired and holds lock forever until shut down or failed. But since it is frequently encountered it is considered separately.
</p>

<p>
	Coordination problems I've described may sound easy but implementing them correctly in fault tolerant way may lead you to the nights of hardcore debugging of highly concurrent code. No fun, believe me, I've seen a project where custom distributed transactions are implemented. Fortunately, <a href="http://zookeeper.apache.org">Apache ZooKeeper</a> comes to rescue by providing set of reliable primitives, building blocks that allow us to tackle coordination problems with ease.    
</p>